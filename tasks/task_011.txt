# Task ID: 11
# Title: Develop Hourly PV Production and Wind Simulation Calculator
# Status: done
# Dependencies: None
# Priority: high
# Description: Create functions that calculate hourly photovoltaic production for a 1 kWp solar PV system and wind power production with wake effects at specified locations, returning DataFrames with time and production values.
# Details:
Implement Python functions that calculate the hourly electricity production of solar PV and wind systems based on location parameters, system configurations, and equipment specifications. The functions should:

1. Accept input parameters for both PV (latitude, longitude, azimuth, tilt, module type) and wind (turbine specifications, layout, wind data)
2. Connect to the PVGIS API for PV and use PyWake for wind simulations
3. Process the retrieved data to extract relevant solar irradiance, temperature, and wind information
4. Allow selection from common PV module types and wind turbine models
5. Calculate solar position and plane-of-array irradiance for PV systems
6. Implement wake loss calculation by running wind simulations with and without wakes (using NoWakeDeficit and BastankhahGaussianDeficit)
7. Create wind distributions that return Weibull fit objects for each sector
8. Support both time series and distribution-based AEP calculations for wind
9. Provide options for using joint frequency matrices (wind rose) as an alternative to Weibull fits
10. Include functionality to merge PV data using hour_of_year for multi-year simulations
11. Return well-structured DataFrames with datetime indices and production values

The implementation should target realistic production values for both technologies. The code should handle error cases gracefully, including API connection failures, invalid parameters, and edge cases in calculations. Include tools for comparing and analyzing discrepancies between time series and distribution-based AEP calculations.

# Test Strategy:
Testing should verify both the functionality and accuracy of the PV and wind production calculators:

1. Unit tests:
   - Test with known locations and compare results to expected ranges
   - Verify correct handling of edge cases (extreme latitudes, night hours, etc.)
   - Test error handling with invalid inputs (out-of-range coordinates, invalid module types)
   - Test wake loss calculations with and without wake effects

2. Integration tests:
   - Compare PV results against PVGIS web calculator output for the same parameters
   - Compare wind results against industry-standard tools
   - Verify API connections and data retrieval work correctly
   - Test with different module/turbine types and system configurations
   - Validate the hour_of_year merging functionality for multi-year simulations

3. Validation tests:
   - Verify production falls within expected ranges for both technologies
   - Check seasonal patterns match expected resource distribution
   - Validate hourly profiles against typical production curves
   - Compare time series and distribution-based AEP calculations
   - Verify normalization and sectorwise fit issues are properly addressed

4. Performance tests:
   - Measure execution time for multiple location calculations
   - Test caching mechanisms if implemented

Create test suites with reference locations across different climate zones and compare results with industry-standard tools. Maximum acceptable deviation should be ±5% for annual totals and ±10% for monthly totals.

# Subtasks:
## 1. Set up project environment and dependencies [done]
### Dependencies: None
### Description: Set up the development environment with all necessary libraries and dependencies for the PV production calculator function.
### Details:
Implementation details:
1. Create a virtual environment for the project
2. Install required packages: pvlib, pandas, numpy, requests
3. Set up a basic project structure with appropriate modules
4. Create a requirements.txt file documenting all dependencies
5. Set up basic logging configuration
6. Create unit test framework structure

Testing approach:
- Verify all dependencies install correctly
- Confirm imports work without errors
- Run a simple test to ensure pvlib and other key libraries function as expected

## 2. Define function parameters and structure [done]
### Dependencies: 11.1
### Description: Define the function signature, input parameters, validation logic, and overall structure of the PV production calculator.
### Details:
Implementation details:
1. Create the main function with parameters: latitude, longitude, azimuth, tilt, and module_type
2. Implement input validation for all parameters (range checks, type checks)
3. Define default values for optional parameters
4. Create docstring with detailed parameter descriptions and return value information
5. Implement error handling structure with appropriate exceptions
6. Define the overall function flow with placeholder functions for each major step

Testing approach:
- Test input validation with valid and invalid parameters
- Verify error handling works correctly for edge cases
- Check that default values are applied correctly

## 3. Implement PVGIS API connection and error handling [done]
### Dependencies: 11.2
### Description: Create a function to connect to the PVGIS API, handle connection issues, and retrieve TMY data for a specified location.
### Details:
Implementation details:
1. Create a function to build the PVGIS API URL with proper parameters
2. Implement the API request with appropriate timeout and retry logic
3. Add error handling for connection failures, API errors, and invalid responses
4. Implement caching mechanism to avoid redundant API calls
5. Parse the API response to extract the TMY data
6. Add logging for API interactions

Testing approach:
- Test with mock responses to simulate successful and failed API calls
- Verify correct handling of different HTTP status codes
- Test with real API calls for a few sample locations
- Verify caching mechanism works correctly

## 4. Process and validate TMY data [done]
### Dependencies: 11.3
### Description: Process the raw TMY data from PVGIS to extract and validate relevant solar irradiance and temperature information.
### Details:
Implementation details:
1. Parse the TMY data structure from PVGIS response
2. Extract relevant columns: global horizontal irradiance (GHI), direct normal irradiance (DNI), diffuse horizontal irradiance (DHI), ambient temperature
3. Convert time information to proper datetime objects with timezone information
4. Validate data completeness and handle missing values
5. Create a structured DataFrame with all necessary meteorological data
6. Implement quality checks for the extracted data

Testing approach:
- Test with sample TMY data files
- Verify correct handling of different data formats
- Check handling of missing or corrupted data
- Validate timezone conversion accuracy

## 5. Implement PV module selection and parameter configuration [done]
### Dependencies: 11.2
### Description: Create a module selection system that allows users to choose from common PV module types or specify custom module parameters.
### Details:
Implementation details:
1. Define a dictionary of common PV module types with their parameters (e.g., efficiency, temperature coefficients)
2. Implement a function to retrieve module parameters based on module_type input
3. Allow for custom module specification through parameter overrides
4. Include default values for common module types (monocrystalline, polycrystalline, thin-film)
5. Validate module parameters for physical correctness
6. Create a module configuration object to be used in subsequent calculations

Testing approach:
- Test selection of each predefined module type
- Verify custom parameter specification works correctly
- Test validation logic with valid and invalid module parameters
- Check that default values are applied correctly when needed

## 6. Calculate solar position using pvlib [done]
### Dependencies: 11.4
### Description: Implement solar position calculation for each hour using pvlib's solar position algorithms based on location and time data.
### Details:
Implementation details:
1. Create a function to calculate solar position (zenith, azimuth) for each timestamp
2. Use pvlib's solar position algorithms with the processed TMY data
3. Handle edge cases like nighttime hours and extreme latitudes
4. Calculate solar elevation angle from zenith angle
5. Filter out nighttime hours where applicable
6. Store solar position data in the working DataFrame

Testing approach:
- Test with different latitudes including edge cases (equator, polar regions)
- Verify calculations against known solar positions for specific dates/locations
- Check handling of nighttime hours
- Validate results against alternative solar position calculators

## 7. Calculate plane-of-array irradiance [done]
### Dependencies: 11.6
### Description: Calculate the irradiance on the tilted plane of the PV array based on system orientation, solar position, and irradiance components.
### Details:
Implementation details:
1. Implement a function to calculate plane-of-array (POA) irradiance
2. Use pvlib's transposition models to convert GHI, DNI, and DHI to POA irradiance
3. Account for system azimuth and tilt angles
4. Implement multiple irradiance transposition models (e.g., Hay, Perez, isotropic)
5. Calculate beam, diffuse, and ground-reflected components
6. Add POA irradiance components to the working DataFrame

Testing approach:
- Test with different azimuth and tilt combinations
- Verify results against known POA values for specific conditions
- Compare results from different transposition models
- Check edge cases (vertical panels, horizontal panels)

## 8. Model PV cell temperature [done]
### Dependencies: 11.5, 11.7
### Description: Implement PV cell temperature modeling based on ambient conditions, irradiance, and module characteristics.
### Details:
Implementation details:
1. Create a function to calculate cell temperature using ambient temperature and irradiance
2. Implement multiple temperature models (e.g., NOCT, Sandia)
3. Account for module-specific temperature coefficients
4. Handle low-irradiance conditions appropriately
5. Calculate and store cell temperature for each hour in the DataFrame
6. Implement validation to ensure physically reasonable temperature values

Testing approach:
- Test with various ambient temperature and irradiance combinations
- Verify results against known cell temperature models
- Check handling of extreme conditions (very high/low temperatures)
- Validate temperature impact on module efficiency

## 9. Calculate DC and AC power production [done]
### Dependencies: 11.7, 11.8
### Description: Calculate the DC and AC power production for each hour accounting for all relevant losses and conversion factors.
### Details:
Implementation details:
1. Create a function to calculate DC power based on POA irradiance, cell temperature, and module parameters
2. Implement PV module performance model using pvlib's single diode model
3. Account for temperature-dependent efficiency changes
4. Model DC to AC conversion with appropriate inverter efficiency
5. Account for system losses (wiring, soiling, mismatch, etc.)
6. Calculate hourly energy production in kWh
7. Normalize results to per kWp capacity

Testing approach:
- Test with various irradiance and temperature combinations
- Verify results against expected production values
- Check handling of edge cases (very low irradiance, extreme temperatures)
- Validate annual production falls within expected range (1600-1800 kWh/kWp for optimal European locations)

## 10. Format and return results [done]
### Dependencies: 11.9
### Description: Format the calculated hourly production data into a well-structured DataFrame and implement the final return functionality.
### Details:
Implementation details:
1. Create a function to format the final results DataFrame
2. Set up a proper datetime index with timezone information
3. Include relevant columns: timestamp, production (kWh), and optionally irradiance and temperature
4. Calculate summary statistics (daily, monthly, annual totals)
5. Implement data export options (CSV, JSON)
6. Add metadata about the calculation parameters
7. Ensure proper handling of different time periods (partial years, etc.)
8. Implement hour_of_year merging option for multi-year simulations

Testing approach:
- Verify DataFrame structure and column names
- Check datetime index formatting and timezone handling
- Validate summary statistics calculations
- Test export functionality with different formats
- Verify full function integration with end-to-end tests using real locations
- Test hour_of_year merging with multi-year datasets

## 11. Implement wind distribution creation [done]
### Dependencies: 11.1
### Description: Create a function to generate wind distributions and return Weibull fit objects for each sector.
### Details:
Implementation details:
1. Develop create_wind_distribution function that processes wind data
2. Calculate frequency distributions for each wind direction sector
3. Fit Weibull distributions to each sector's wind speed data
4. Return Weibull fit objects for each sector that can be used in simulations
5. Include validation and error handling for input data
6. Add options for sector size configuration

Testing approach:
- Test with sample wind datasets
- Verify Weibull parameters are physically reasonable
- Compare fitted distributions to original data histograms
- Check handling of sectors with limited data points

## 12. Implement wake loss calculation [done]
### Dependencies: 11.11
### Description: Develop functionality to calculate wake losses by running simulations with and without wake effects.
### Details:
Implementation details:
1. Create functions to run wind farm simulations using PyWake
2. Implement simulations with NoWakeDeficit for baseline production
3. Implement simulations with BastankhahGaussianDeficit for wake-affected production
4. Calculate wake losses as the difference between the two simulations
5. Support both time series and distribution-based approaches
6. Add detailed logging of wake effect calculations

Testing approach:
- Test with various wind farm layouts
- Verify wake losses increase with closer turbine spacing
- Compare results to theoretical expectations
- Validate against other wake models when possible

## 13. Implement time series and distribution-based AEP calculations [done]
### Dependencies: 11.12
### Description: Create functions to calculate Annual Energy Production using both time series and distribution-based approaches.
### Details:
Implementation details:
1. Implement time series AEP calculation using hourly wind data
2. Implement distribution-based AEP using Weibull fits or joint frequency matrices
3. Add functionality to compare results from both approaches
4. Investigate and document reasons for discrepancies (normalization, sectorwise fit issues)
5. Provide options to adjust calculation parameters to minimize differences
6. Include detailed reporting of calculation steps and intermediate results

Testing approach:
- Compare time series and distribution-based results for consistency
- Verify total AEP values against industry benchmarks
- Test with various wind regimes and farm configurations
- Validate normalization approaches

## 14. Implement data merging and visualization [done]
### Dependencies: 11.10, 11.13
### Description: Create functions to merge PV and wind data and visualize combined results.
### Details:
Implementation details:
1. Develop functions to merge PV and wind production data
2. Implement hour_of_year merging for PV data in multi-year simulations
3. Create visualization functions for combined production profiles
4. Add options for temporal aggregation (hourly, daily, monthly)
5. Implement export functionality for combined datasets
6. Create summary statistics for combined production

Testing approach:
- Test merging with various dataset combinations
- Verify hour_of_year merging works correctly
- Check visualization outputs for clarity and accuracy
- Validate combined statistics against individual component sums

## 15. Code cleanup and documentation [done]
### Dependencies: 11.14
### Description: Clean up code, remove accidental pastes, and improve documentation throughout the codebase.
### Details:
Implementation details:
1. Review and clean up all code files
2. Remove any accidental code pastes, particularly in run_simulation_weibull.py
3. Improve code clarity with better variable names and comments
4. Create comprehensive documentation for all functions
5. Add usage examples for common scenarios
6. Create a troubleshooting guide for common issues
7. Document the workflow for combined PV and wind simulations

Testing approach:
- Verify documentation accuracy with example runs
- Check that code cleanup doesn't affect functionality
- Review documentation for completeness and clarity
- Test examples to ensure they work as described

